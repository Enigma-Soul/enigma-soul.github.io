{"/books/":{"data":{"":"一些书的读后感(笔记)"},"title":"读后感???"},"/books/sftj/":{"data":{"":"《算法图解》 (ISBN:978-7-115-44763-0) 的笔记"},"title":"《算法图解》"},"/books/sftj/1/":{"data":{"":"每一章都不知道说啥 词穷了","二分查找#二分查找":"二分查找的复杂度是 O(log⁡n)O(\\log n)O(logn) 如图:\n我为了更明显 把普通查找 O(n)O(n)O(n)做了对比 不难发现 两者所需时间相差极大\n代码实现:\nlower_bound(); upper_bound(); // STL","各个时间复杂度比对#各个时间复杂度比对:":"各个时间复杂度差距巨大 (没加/(O(n!)/) 这个增长率太大 加上全没了)\nccc是算法所需时间的固定量 算法真实运行时间其实是 O(x)∗cO(x)*cO(x)∗c 其中xxx代指任何\n但在一般情况下 不统计ccc所需时间 即便他非常大 因为增长的更快·\n计算: 在有递归的情况下 一般是O(调用栈高度)∗O(每层所需时间)O(\\text{调用栈高度}) * O(\\text{每层所需时间})O(调用栈高度)∗O(每层所需时间)","大o表示法#大O表示法":"后面一章也写道这了","旅行商问题#旅行商问题":"P1433 吃奶酪 典型的旅行商问题 (不会写)","最坏情况与平均情况#最坏情况与平均情况":""},"title":"第一章"},"/books/sftj/2/":{"data":{"":"","内存#内存":"数组是一种连续的空间 每次访问都会访问开头地址+编号 所以复杂度是O(1)O(1)O(1)\n链表是一种不连续的空间 每次访问都会访问下一个地址 所以复杂度是O(n)O(n)O(n)\n增删改查对比表:\n操作 数组 链表 增 O(n)O(n)O(n) O(1)O(1)O(1) 删 O(n)O(n)O(n) O(1)O(1)O(1) 改 O(1)O(1)O(1) O(n)O(n)O(n) 查 O(1)O(1)O(1) O(n)O(n)O(n)","选择排序#选择排序":"选择排序同冒泡一样的复杂度是 O(n2)O(n^2)O(n2) 慢不行的\n如图: 原理及每次都选最小(最大)的一个 依次向后排 直到有序"},"title":"第二章"},"/books/sftj/3/":{"data":{"":"","栈#栈":"栈是一种先进后出(FILO)的数据结构 程序运行时会有调用栈call stack 当函数调用时 会分配一部分内存 将其压入调用栈中 函数结束时 会弹出调用栈中的内存\n缺陷:\n栈空间有限 容易溢出(MLE) 效率低下","递归#递归":"简单来说就是自己调自己","递归的两个条件#递归的两个条件":"基线条件与递归条件 他俩是完全相反的两个\n基线条件：停止递归的条件 递归条件：继续递归的条件"},"title":"第三章"},"/glossary":{"data":{},"title":"Glossary"},"/oi-blog/":{"data":{"":"OI 笔记"},"title":"OI Blog"},"/oi-blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/array/":{"data":{"":"","代码实现#代码实现":"int arr[5] = {0}; // 默认初始化为0 std::array\u003cint, 5\u003e arr2 = {0}; // C++11支持 以上两种方法等效 但C++标准写法std::array更安全 不是哥们谁没事喜欢写着一坨啊","向量#向量":"C++ STL中的向量是一种动态数组 可以在 O(1) 的时间复杂度内访问任意一个元素\nstd::vector\u003cint\u003e arr; 我觉得这个可以放std里讲","概述#概述":"数组是C/C++很重要的一环 是一种 线性表 特点: 随机访问 ，即可以在 O(1) 的时间复杂度内访问任意一个元素。"},"title":"数组"}}